1. 图片懒加载
   ------src/scroll事件监听/节流防抖/dom的data-xxx属性（https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/dataset）
        <div id="user" data-id="1234567890" data-user="johndoe" data-date-of-birth>John Doe</div>
        const el = document.querySelector('#user');
        // el.id === 'user'
        // el.dataset.id === '1234567890'
        // el.dataset.user === 'johndoe'
        // el.dataset.dateOfBirth === ''

        // set the data attribute
        el.dataset.dateOfBirth = '1960-10-03';
        // Result: el.dataset.dateOfBirth === 1960-10-03

        delete el.dataset.dateOfBirth;
        // Result: el.dataset.dateOfBirth === undefined

        // 'someDataAttr' in el.dataset === false
        el.dataset.someDataAttr = 'mydata';
        // Result: 'someDataAttr' in el.dataset === true

   -------repaint重绘 reflow回流 （浏览器优化）
       现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。

       主要包括以下属性或方法：

       offsetTop、offsetLeft、offsetWidth、offsetHeight
       scrollTop、scrollLeft、scrollWidth、scrollHeight
       clientTop、clientLeft、clientWidth、clientHeight
       width、height
       getComputedStyle()
       getBoundingClientRect()
       所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。

      ---优化；
      1.避免使用table、
      2.尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。
      3.避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。
        span {}
        浏览器只需要找到页面中所有的 span 标签然后设置颜色
        div > a > span {
        }
        浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。
      4.将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘
      5.js 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流

   -------Array-like (arguments only has length)
       function func1(a, b, c) {
         console.log(arguments[0]);
         // expected output: 1

         console.log(arguments[1]);
         // expected output: 2

         console.log(arguments[2]);
         // expected output: 3
       }
       --- 将arguments转成数组
       var args = Array.prototype.slice.call(arguments);
       var args = [].slice.call(arguments);

       // ES2015
       const args = Array.from(arguments);
       const args = [...arguments];
       -----
       console.log(typeof arguments);    // 'object'

   func1(1, 2, 3);
   -------节流防抖

















2. 写一个深拷贝，考虑 正则，Date这种类型的数据
3. h5 头部标签
